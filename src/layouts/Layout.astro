---
interface Props {
  title?: string;
  description?: string;
}

const {
  title = "RoomieMatch | Find Your Perfect Living Space in India",
  description = "Discover amazing shared homes and compatible roommates across India. Simple, safe, and joyful.",
} = Astro.props;
---

<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="description" content={description} />
    <link rel="icon" type="image/svg+xml" href="/favicon.svg" />

    <!-- Preconnect to font sources -->
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />

    <!-- Load fonts -->
    <link
      href="https://fonts.googleapis.com/css2?family=Plus+Jakarta+Sans:wght@400;500;600;700;800&family=DM+Sans:wght@400;500;600;700&display=swap"
      rel="stylesheet"
    />

    <!-- Leaflet CSS for Maps -->
    <link
      rel="stylesheet"
      href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
      integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
      crossorigin=""
    />

    <title>{title}</title>
  </head>
  <body>
    <slot />

    <!-- Lenis Smooth Scrolling -->
    <script>
      import Lenis from "lenis";

      // Initialize Lenis
      const lenis = new Lenis({
        duration: 1.2,
        easing: (t: number) => Math.min(1, 1.001 - Math.pow(2, -10 * t)),
        smoothWheel: true,
        touchMultiplier: 2,
      });

      // RAF loop
      function raf(time: number) {
        lenis.raf(time);
        requestAnimationFrame(raf);
      }
      requestAnimationFrame(raf);

      // Make lenis available globally
      (window as any).lenis = lenis;
    </script>

    <!-- Scroll Animation Script - Enhanced System -->
    <script>
      // ═══════════════════════════════════════════════════════════════════════
      // SECTION OBSERVER - Fade in entire sections
      // ═══════════════════════════════════════════════════════════════════════
      // ═══════════════════════════════════════════════════════════════════════
      // SECTION OBSERVER - Fade in/out entire sections
      // ═══════════════════════════════════════════════════════════════════════
      const sectionObserver = new IntersectionObserver(
        (entries) => {
          entries.forEach((entry) => {
            if (entry.isIntersecting) {
              entry.target.classList.add("is-visible");
            } else {
              // User requested fade out - removing class resets the state
              // We only remove if it's strictly NOT intersecting to allow fade out
              if (entry.boundingClientRect.top > 0) {
                // Only fade out if scrolling DOWN past it (moved out of view to top)
                // Or actually, user wants "between sections".
                // Let's just toggle standard visibility.
                entry.target.classList.remove("is-visible");
              }
            }
          });
        },
        {
          root: null,
          rootMargin: "-10% 0px -10% 0px", // Trigger slightly inside the viewport
          threshold: 0.1,
        },
      );

      // ═══════════════════════════════════════════════════════════════════════
      // ELEMENT OBSERVER - Animate individual elements within sections
      // ═══════════════════════════════════════════════════════════════════════
      const elementObserver = new IntersectionObserver(
        (entries) => {
          entries.forEach((entry) => {
            if (entry.isIntersecting) {
              const delay = entry.target.getAttribute("data-delay");
              const delayMs = delay ? parseInt(delay) * 100 : 0;

              setTimeout(() => {
                entry.target.classList.add("is-visible");
              }, delayMs);
            } else {
              // Optional: Reset elements too if desired
              // entry.target.classList.remove("is-visible");
            }
          });
        },
        {
          root: null,
          rootMargin: "0px 0px -10% 0px",
          threshold: 0.1,
        },
      );

      // ═══════════════════════════════════════════════════════════════════════
      // PARALLAX EFFECT - Smooth parallax on scroll
      // ═══════════════════════════════════════════════════════════════════════
      let parallaxElements: Element[] = [];

      function updateParallax() {
        const scrollY = window.scrollY;

        parallaxElements.forEach((el) => {
          const speed =
            parseFloat(
              getComputedStyle(el).getPropertyValue("--parallax-speed"),
            ) || 0.1;
          const rect = el.getBoundingClientRect();
          const centerY = rect.top + rect.height / 2;
          const offset = (window.innerHeight / 2 - centerY) * speed;

          (el as HTMLElement).style.transform = `translateY(${offset}px)`;
        });
      }

      // ═══════════════════════════════════════════════════════════════════════
      // SCROLL PROGRESS BAR
      // ═══════════════════════════════════════════════════════════════════════
      function updateScrollProgress() {
        const scrollProgress = document.querySelector(".scroll-progress");
        if (scrollProgress) {
          const scrollHeight =
            document.documentElement.scrollHeight - window.innerHeight;
          const progress = window.scrollY / scrollHeight;
          (scrollProgress as HTMLElement).style.transform =
            `scaleX(${progress})`;
        }
      }

      // ═══════════════════════════════════════════════════════════════════════
      // INITIALIZATION
      // ═══════════════════════════════════════════════════════════════════════
      document.addEventListener("DOMContentLoaded", () => {
        // Observe all sections
        const sections = document.querySelectorAll(".section");
        sections.forEach((section) => sectionObserver.observe(section));

        // Observe all animated elements
        const animatedElements = document.querySelectorAll("[data-animate]");
        animatedElements.forEach((el) => elementObserver.observe(el));

        // Setup parallax elements
        parallaxElements = Array.from(
          document.querySelectorAll("[data-parallax]"),
        );

        // Add scroll listeners for parallax and progress
        window.addEventListener(
          "scroll",
          () => {
            updateParallax();
            updateScrollProgress();
          },
          { passive: true },
        );

        // Initial progress update
        updateScrollProgress();
      });
    </script>

    <!-- Leaflet JS for Maps -->
    <script
      src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
      integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
      crossorigin=""></script>
  </body>
</html>

<style is:global>
  @import "../styles/global.css";

  /* Lenis Smooth Scroll Styles */
  html.lenis,
  html.lenis body {
    height: auto;
  }

  .lenis.lenis-smooth {
    scroll-behavior: auto !important;
  }

  .lenis.lenis-smooth [data-lenis-prevent] {
    overscroll-behavior: contain;
  }

  .lenis.lenis-stopped {
    overflow: hidden;
  }

  .lenis.lenis-scrolling iframe {
    pointer-events: none;
  }
</style>
